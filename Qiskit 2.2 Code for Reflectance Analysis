"""
=====================================================================
QUANTUM-INSPIRED SPECTRAL ANALYSIS WITH AMPLITUDE ENCODING
Application Example: 3I/ATLAS-like Reflectance Spectrum
=====================================================================

Author: IONITA MIHAI
Version: 2.0
Date: 2025-12-19

SCOPE & SCIENTIFIC DISCLAIMER
---------------------------------------------------------------------
This program demonstrates a HYBRID CLASSICAL–QUANTUM WORKFLOW for
spectral analysis using:

• Classical spectral metrics (slope, band depth)
• Quantum amplitude encoding (statevector representation)

IMPORTANT CLARIFICATIONS:
• This code DOES NOT claim quantum advantage
• Quantum circuits are NOT used for computation here
• No quantum algorithm (QAOA, VQE, etc.) is implemented
• The quantum state is used as a DATA REPRESENTATION ONLY
• All physical interpretation remains classical

The quantum statevector serves as a mathematical embedding
of normalized spectral data, suitable for future similarity,
distance, or kernel-based quantum methods.

This code is intended for:
• methodological demonstration
• educational use
• preparatory work for quantum machine learning

NOT for physical inference based on quantum mechanics.

What: Performs classical analysis (linear fit for slope, interpolation for band depth);
normalizes data and initializes Statevector for quantum representation.

Why: Illustrates amplitude encoding for potential quantum processing of astronomical spectra,
e.g., in quantum kernel methods or classification.

Quantum-specific: Statevector directly embeds normalized reflectance as amplitudes in Hilbert space.
No gates applied; circuit is placeholder for extensions (e.g., feature maps).

How it works: Normalize vector to unit norm (probabilistic interpretation); create Statevector.
Classical parts use NumPy for polyfit and interp.

How to use: Run with dummy data; replace wavelength/reflectance with real GMOS/X-shooter/SpeX data.

Properties: Handles non-power-of-2 lengths implicitly (Statevector allows it); prints amplitudes.

Limitations: Dummy data; for larger spectra, pad to 2^n or use circuit-based encoding.
Statevector is simulation-only; for hardware, use quantum circuits with amplitude preparation.

This module implements a quantum decision system for optimizing phosphorus fertilizer
application across multiple agricultural fields using Qiskit quantum circuits.
The quantum algorithm balances nutrient deficits against fertilizer costs to
generate probabilistic recommendations with economic analysis.

References:
- Brouder & Volenec (2020) - Field crop nutrient requirements and costs
- Zhou et al. (2025) - Code Comments for Quantum Software Development Kits
- Qiskit Quantum SDK documentation for circuit design and execution

Quantum Circuit Design:
- Each qubit represents a field fertilizer decision (|0⟩=skip, |1⟩=apply)
- Ry rotations encode deficit/cost trade-offs into quantum amplitudes
- Controlled-X gates create entanglement to model field dependencies
- Measurement collapses superposition into specific recommendations
Note: As of December 19, 2025, Qiskit >=2.2 recommended; uses AerSimulator if needed for extensions.
=====================================================================
"""

# =====================================================================
# 1) ENVIRONMENT & DEPENDENCIES
# =====================================================================

# NOTE:
# Installation commands (pip install ...) are intentionally omitted
# from the source file for reproducibility and best practice.
#
# Required packages:
#   numpy
#   pandas
#   matplotlib
#   qiskit >= 2.2
#   qiskit-aer
!pip install qiskit qiskit-aer
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

from qiskit import QuantumCircuit
from qiskit.quantum_info import Statevector
from qiskit_aer import AerSimulator

# =====================================================================
# 2) INPUT DATA (EXAMPLE SPECTRAL MEASUREMENTS)
# =====================================================================

"""
This dataset is a SMALL, SYNTHETIC example resembling
optical–NIR reflectance spectra obtained from instruments such as:

• GMOS
• X-shooter
• SpeX

Replace these arrays with real calibrated observational data
for scientific use.
"""

wavelength = np.array([
    0.5, 0.6, 0.7, 0.8, 0.9,
    1.0, 1.5, 2.0, 2.2
])  # microns

reflectance = np.array([
    1.00, 1.11, 1.13, 1.15, 1.16,
    1.18, 1.19, 1.05, 1.02
])

# =====================================================================
# 3) CLASSICAL SPECTRAL METRICS
# =====================================================================

# ---------------------------------------------------------------------
# 3.1 Spectral slope (0.5–0.8 µm)
# ---------------------------------------------------------------------

mask = (wavelength >= 0.5) & (wavelength <= 0.8)
x = wavelength[mask]
y = reflectance[mask]

# Linear regression
slope, intercept = np.polyfit(x, y, 1)

# Convert slope to % per 1000 Å
# 1 µm = 10,000 Å
slope_percent = (slope / intercept) * 100 * (1000 / 10000)

print("=" * 60)
print("CLASSICAL SPECTRAL ANALYSIS")
print("=" * 60)
print(f"Spectral slope (0.5–0.8 µm): {slope_percent:.2f} % / 1000 Å")

# ---------------------------------------------------------------------
# 3.2 Absorption band depth at 2.0 µm
# ---------------------------------------------------------------------

continuum = np.interp(
    2.0,
    [1.5, 2.2],
    [reflectance[6], reflectance[8]]
)

band_depth = (continuum - reflectance[7]) / continuum * 100

print(f"Band depth at 2.0 µm:        {band_depth:.2f} %")

# =====================================================================
# 4) QUANTUM AMPLITUDE ENCODING
# =====================================================================

"""
Amplitude encoding maps a normalized classical vector
into a quantum state:

|ψ⟩ = Σᵢ xᵢ |i⟩

IMPORTANT:
• This step is a DATA REPRESENTATION
• No quantum processing is performed
• Statevector is computed classically
"""

# Normalize reflectance vector
vector = reflectance / np.linalg.norm(reflectance)

# Determine required number of qubits
n_qubits = int(np.ceil(np.log2(len(vector))))

# Create an empty circuit (no gates applied)
qc = QuantumCircuit(n_qubits)

# Directly construct statevector from data
state = Statevector(vector)

print("\nQUANTUM STATE REPRESENTATION")
print("-" * 60)
print(f"Number of qubits required: {n_qubits}")
print("Statevector amplitudes:")
print(state.data)

# =====================================================================
# 5) VISUALIZATION
# =====================================================================

plt.figure(figsize=(8, 4))
plt.plot(wavelength, reflectance, marker="o", linewidth=2)
plt.xlabel("Wavelength (µm)")
plt.ylabel("Reflectance")
plt.title("Reflectance Spectrum (Example 3I/ATLAS-like)")
plt.grid(alpha=0.3)
plt.tight_layout()
plt.show()

# =====================================================================
# 6) INTERPRETATION & LIMITATIONS
# =====================================================================

print("\nINTERPRETATION & LIMITATIONS")
print("-" * 60)

print("• Spectral slope indicates red optical behavior")
print("• Weak 2.0 µm absorption suggests limited ice signature")
print("• Quantum state encodes spectral shape, not physics")
print("• No quantum inference is performed")
print("• Suitable as input to future quantum ML pipelines")

# =====================================================================
# 7) FINAL NOTES
# =====================================================================

print("\nFINAL NOTES")
print("=" * 60)
print("This file demonstrates:")
print("1. Classical spectral feature extraction")
print("2. Safe amplitude encoding into a quantum state")
print("3. Clear separation between physics and computation")
print("4. A reproducible starting point for quantum ML research")

print("\nEND OF FILE")
