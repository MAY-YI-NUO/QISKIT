# =====================================================================
# SIMPLE GROVER'S ALGORITHM FOR DNA SEQUENCE SEARCH
# =====================================================================
# Furigana-style annotation (interpretive layer):
# This script is a *conceptual and educational demonstration* inspired by
# the paper:
#
#   "Genetic Engineering Through Quantum Circuits"
#   BioRxiv: https://doi.org/10.1101/2025.05.02.654535
#
# IMPORTANT SCOPE DISCLAIMER:
# - This code does NOT reproduce the experimental results of the paper.
# - This code does NOT implement the full DNA oracle described in the paper.
# - This code demonstrates Grover-style *conceptual principles* only.
#
# Analogy:
#   Executable Python/Qiskit code  -> Kanji (core meaning)
#   Comments & explanations       -> Furigana (how to read/interpret)
# =====================================================================
"""
    Simulate the quantum search process conceptually.
    
    What: This function emulates Grover's algorithm for searching a DNA sequence in a database.
    Why: Demonstrates quantum advantage in unstructured search, relevant for bioinformatics.
    How-it-is-done: Encodes DNA to binary, computes complexities, simulates amplitude amplification,
    visualizes results, and runs a small Qiskit circuit if available.
    How-to-use: Call with target_dna (str) and database_size (int, power of 4 for DNA).
    Example: simulate_quantum_search("GCTA", 256) for a 4-nucleotide search in 256 possibilities.
    Property: Assumes unsorted database; success probability approaches 100% with optimal iterations.
    Quantum-algorithm: Grover's provides O(‚àöN) queries vs. classical O(N).
    Quantum-circuit-model: Involves oracle (marks target) and diffusion (amplifies amplitude).
    Mathematics-for-quantum: Iteration count ‚âà (œÄ/4)‚àöN; probability = sin¬≤((2k+1)Œ∏), Œ∏ = arcsin(1/‚àöN).
"""
print("Setting up quantum computing environment...")

# ---------------------------------------------------------------------
# ENVIRONMENT CHECK (Furigana: setup explanation)
# ---------------------------------------------------------------------
# This section checks the Python environment and attempts installation.
# In research or production, dependency installation should be handled
# outside the script (e.g., requirements.txt).
# ---------------------------------------------------------------------

import sys
print(f"Python version: {sys.version}")

print("\nInstalling Qiskit (if not already installed)...")

# NOTE:
# This shell command is notebook-specific.
# It is included for educational convenience only.
!pip install qiskit --break-system-packages 2>&1 | grep -v "already satisfied"

print("\nInstallation complete. Now running quantum simulation...")

# ---------------------------------------------------------------------
# IMPORTS (Executable layer)
# ---------------------------------------------------------------------
# Attempt to import Qiskit; fall back to conceptual-only mode if unavailable.
# ---------------------------------------------------------------------

try:
    from qiskit import QuantumCircuit, Aer, execute
    from qiskit.visualization import plot_histogram
    import matplotlib.pyplot as plt
    import numpy as np

    print("‚úÖ Qiskit successfully imported!")

except ImportError as e:
    print(f"‚ùå Import error: {e}")
    print("‚ö†Ô∏è Falling back to conceptual (non-quantum) simulation")

    import numpy as np
    import matplotlib.pyplot as plt


# ---------------------------------------------------------------------
# DNA ENCODING SCHEME
# ---------------------------------------------------------------------
# Furigana-style annotation:
# This binary encoding is a *didactic mapping*, not a biochemical model.
# Each nucleotide is mapped to 2 classical bits.
# ---------------------------------------------------------------------

DNA_TO_BINARY = {
    'A': '00',
    'T': '01',
    'G': '10',
    'C': '11'
}

BINARY_TO_DNA = {
    '00': 'A',
    '01': 'T',
    '10': 'G',
    '11': 'C'
}


def simulate_quantum_search(target_dna="ATCG", database_size=16):
    """
    Simulate a Grover-like DNA sequence search.

    Furigana-style annotation (critical):
    -----------------------------------
    This function:
    - Illustrates Grover's quadratic speedup conceptually
    - Uses simplified probability formulas
    - Does NOT claim computational quantum advantage
    - Uses toy-sized databases for clarity

    Mapping to real quantum computing:
    - Superposition     -> Hadamard gates
    - Oracle            -> Phase flip (CZ)
    - Diffusion         -> Inversion about the mean
    """

    print("\n" + "=" * 60)
    print("QUANTUM DNA SEARCH SIMULATION (CONCEPTUAL)")
    print("Inspired by: Genetic Engineering Through Quantum Circuits")
    print("=" * 60)

    # -----------------------------------------------------------------
    # TARGET ENCODING
    # -----------------------------------------------------------------
    target_binary = ''.join(DNA_TO_BINARY.get(nuc, '00') for nuc in target_dna)

    print(f"\nüî¨ Target DNA Sequence: {target_dna}")
    print(f"üî¨ Binary Encoding: {target_binary}")
    print(f"üî¨ Target occupies 1 out of {database_size} possible sequences")

    # -----------------------------------------------------------------
    # COMPLEXITY COMPARISON (Conceptual math, not execution time)
    # -----------------------------------------------------------------
    classical_attempts = database_size            # O(N)
    quantum_attempts = int(np.sqrt(database_size))  # O(‚àöN)

    print("\nüìä Complexity Comparison:")
    print(f"   Classical (linear search): O(N)  = {classical_attempts}")
    print(f"   Quantum (Grover's):        O(‚àöN) = {quantum_attempts}")
    print(f"   Speedup factor: {classical_attempts / quantum_attempts:.1f}x")

    # -----------------------------------------------------------------
    # AMPLITUDE AMPLIFICATION (Analytical formula)
    # -----------------------------------------------------------------
    print("\nüîÆ Quantum Amplitude Amplification:")

    initial_prob = 1 / database_size * 100
    print(f"   Step 1: Initial superposition ‚Üí {initial_prob:.2f}% each")

    grover_iterations = int((np.pi / 4) * np.sqrt(database_size))
    print(f"   Step 2: Apply {grover_iterations} Grover iterations")

    theta = np.arcsin(1 / np.sqrt(database_size))
    final_prob = (np.sin((2 * grover_iterations + 1) * theta) ** 2) * 100

    print(f"   Step 3: Target probability ‚Üí {final_prob:.1f}%")

    # -----------------------------------------------------------------
    # VISUALIZATION
    # -----------------------------------------------------------------
    fig, axes = plt.subplots(1, 2, figsize=(12, 5))

    n_values = np.arange(1, 101)
    axes[0].plot(n_values, n_values, label="Classical O(N)", linewidth=2)
    axes[0].plot(n_values, np.sqrt(n_values), label="Quantum O(‚àöN)", linewidth=2)
    axes[0].axvline(database_size, linestyle="--", label="Database size")
    axes[0].set_title("Search Complexity Comparison")
    axes[0].legend()
    axes[0].grid(alpha=0.3)

    iterations = np.arange(0, grover_iterations + 1)
    probs = [(np.sin((2 * k + 1) * theta) ** 2) * 100 for k in iterations]

    axes[1].plot(iterations, probs, marker="o")
    axes[1].set_title("Amplitude Amplification")
    axes[1].set_xlabel("Grover Iterations")
    axes[1].set_ylabel("Target Probability (%)")
    axes[1].grid(alpha=0.3)

    plt.tight_layout()
    plt.show()

    # -----------------------------------------------------------------
    # SAMPLE DNA DATABASE (Illustrative only)
    # -----------------------------------------------------------------
    print("\nüß¨ Sample DNA Database:")
    sample_sequences = [
        "AAAA", "ATCG", "TTTT", "GGGG", "CCCC",
        "AGCT", "TCGA", "GATC", "CTAG", "ACGT"
    ]

    for i, seq in enumerate(sample_sequences, 1):
        marker = "üéØ" if seq == target_dna else "  "
        print(f"{marker} {i:2d}. {seq}")

    # -----------------------------------------------------------------
    # OPTIONAL REAL QISKIT CIRCUIT (Toy example)
    # -----------------------------------------------------------------
    try:
        print("\n‚ö° Running minimal Qiskit circuit (demonstration only)")

        n_qubits = 2
        qc = QuantumCircuit(n_qubits, n_qubits)

        qc.h(range(n_qubits))
        qc.cz(0, 1)
        qc.h(range(n_qubits))
        qc.x(range(n_qubits))
        qc.cz(0, 1)
        qc.x(range(n_qubits))
        qc.h(range(n_qubits))
        qc.measure(range(n_qubits), range(n_qubits))

        simulator = Aer.get_backend("qasm_simulator")
        result = execute(qc, simulator, shots=1024).result()
        counts = result.get_counts()

        print("\nüìä Measurement Results:")
        for state, count in sorted(counts.items()):
            print(f"   |{state}‚ü© ‚Üí {count / 1024 * 100:.1f}%")

        print("\nüîå Circuit Diagram:")
        print(qc.draw(output="text"))

    except Exception:
        print("\n‚ö†Ô∏è Quantum backend unavailable ‚Äì conceptual mode only")

    # -----------------------------------------------------------------
    # PAPER CONTEXT SUMMARY (Interpretive layer)
    # -----------------------------------------------------------------
    print("\n" + "=" * 60)
    print("RESEARCH CONTEXT (ANNOTATION)")
    print("=" * 60)
    print("""
    ‚Ä¢ Paper demonstrates Grover-based DNA search on real hardware
    ‚Ä¢ Database sizes up to 3022 nucleotides
    ‚Ä¢ Success probability ~26‚Äì28%
    ‚Ä¢ Synthetic genetic blocks implemented in JCVI-syn3
    ‚Ä¢ Quadratic theoretical speedup confirmed
    """)

    print(f"\nüí° Quantum advantage becomes meaningful at much larger N")
    print("=" * 60)


# ---------------------------------------------------------------------
# SCRIPT ENTRY POINT
# ---------------------------------------------------------------------
if __name__ == "__main__":

    sequences_to_search = ["AT", "ATCG", "GCTA"]

    for seq in sequences_to_search:
        simulate_quantum_search(seq, database_size=2 ** (len(seq) * 2))
        print("\n" + "=" * 60 + "\n")
