# COMPLETE QUANTUM-INSPIRED PCR PRIMER SEARCH FOR GOOGLE COLAB
# Copy and paste ALL of this code into a new Colab cell and run it

# Install necessary packages (Colab already has numpy)
!pip install qiskit matplotlib -q  # Install Qiskit for actual quantum simulation

print("üî¨ QUANTUM-INSPIRED PCR PRIMER SEARCH IN MAIZE ADH1 GENE")
print("="*60)

import numpy as np
import time
from google.colab import files
import matplotlib.pyplot as plt

# Define primer pairs
primer_pairs = {
    "Pair 1": {
        "Fwd": "CGTCGTTTCCCATCTCTTCCTCC",
        "Rev": "GACTGAGGGTCTCGGAGTGG"
    },
    "Pair 2": {
        "Fwd": "TTGGACTAGAAATCTCGTGCTGA",
        "Rev": "GCTACATAGGGAGCCTTGTCCT"
    }
}

# Default sequence
default_adh1_sequence = """GGATCCAAACAGTCACTTAGGATATGTTTGGAAGCACACCGACATGTTTGGAAGCACACAGTTTTAAAAA
ACTATTTTCTATCCTCACTTTCTTGAAAATGTTTTATGAAAAAAATTGGGTGGGGTGTTTGGAACCTAGT
TTCTAGTTTTTTTATAAGGAGAGTAGCTTCTTGGTTTTAGTTAGGAGAGAGTAGCTTCTTGATTTTTAAG
AAACTAAGAATCCAGTTTCTATAAACTGAGACATAAACAAGTATATTTGGAATCACTCTAGTTTGTACAA
ACCAATTTCTTAGAAATTGGATGCTTATAAATAGGCCCTCAATGTCCTTGTTGGGTTTATGAAATTTACA
TCTATTACCATTATTTTAAAAATAGACGAAGAATATGTTAGTAATTATGTATAAAAAACTAGAAACTATT
TTAAAAAAAAACTGAGTTCCAGTTACCTTTATCTAATTCTTTTATTAAGCTAATTTTAGAAACTGAGGAT
AGAAACTGTTTTAAAAAACTGGTGTGCTTCTGTTTTAACTCTTCGTAAGAACAGTGGTACTGCCCGTGTC
TATATTAACTCTTCTGTTTAAAGCCAACATGACATGCTTGCGTGCGGTGAAAATGTGAAATGCCATCGCT
GTGCTACAACTTTTCGGCTCCCTCCTGCTTCGGTGCTTCCATATGCCCCTGCACGGCGTCTAGAAATCCT
AATGGCTGAATACTCAGCAGCACACCTGTCCGCCTAGCCCGCTACGCGTGCACAGAAAACAATTTTTTTG
TCCACACACGCGCGCGCTCCGAGCCGCAGATCCGAGCTAGCGCAGGCGCATCCGACGGCCACGACAGCGT
GCCGTCCTCCGCCGCCACCGCTTAGGCGATTGTCCGCACCCCACCAGTCCACCACCTCCCCCACGAGCGA
AAACCACGTCCACGGACCACGGCTATGTTCCACTCCAGGTGGAGCTGCAGCCCCGGTTTCGCAAGCCGCG
CACGTGGTTTGCTTGCCCACAGGCGGCCAAACCGCACCCTCCTTCCCGTCGTTTCCCATCTCTTCCTCCT
TTAGAGCTACCACTATATAAATCAGGGCTCATTTTCTCGCTCCTCACAGGCTCATCTCGCTTTGGATCGA
TTGGTTTCGTAACTGGTGAAGGACTGAGGGTCTCGGAGTGGATGATTTGGGATTCTGTTCGAAGATTTGC
GGAGGGGGGCAATGGCGACCGCGGGGAAGGTGATCAAGTGCAAAGGTCCGCCTTGTTTCTCCTCTGTCTC
TTGATCTGACTAATCTTGGTTTATGATTCGTTGAGTAATTTTGGGGAAAGCTTCGTCCACAGTTTTTTTT
TCGATGAACAGTGCCGCAGTGGCGCTGATCTTGTATGCTATCCTGCAATCGTGGTGAACTTATGTCTTTT
ATATCCTTCACTACCATGAAAAGACTAGTAATCTTTCTCGATGTAACATCGTCCAGCACTGCTATTACCG
TGTGGTCCATCCGACAGTCTGGCTGAACACATCATACGATATTGAGCAAAGATCTATCTTCCCTGTTCTT
TAATGAAAGACGTCATTTTCATCAGTATGATCTAAGAATGTTGCAACTTGCAAGGAGGCGTTTCTTTCTT
TGAATTTAACTAACTCGTTGAGTGGCCCTGTTTCTCGGACGTAAGGCCTTTGCTGCTCCACACATGTCCA
TTCGAATTTTACCGTGTTTAGCAAGGGCGAAAAGTTTGCATCTTGATGATTTAGCTTGACTATGCGATTG
CTTTCCTGGACCCGTGCAGCTGCGGTGGCATGGGAGGCCGGCAAGCCACTGTCGATCGAGGAGGTGGAGG
TAGCGCCTCCGCAGGCCATGGAGGTGCGCGTCAAGATCCTCTTCACCTCGCTCTGCCACACCGACGTCTA
CTTCTGGGAGGCCAAGGTATCTAATCAGCCATCCCATTTGTGATCTTTGTCAGTAGATATGATACAACAA
CTCGCGGTTGACTTGCGCCTTCTTGGCGGCTTATCTGTCTCAGGGGCAGACTCCCGTGTTCCCTCGGATC
TTTGGCCATGAGGCTGGAGGGTATGTTCTATTCCCCGATTTACTTCACTATGTTGCTGACTATAGATGTG
CTGTGTTTATATTTTACATATTTATTATGTTTTTGCGTCTGAATTTATGGGTATGGTTGGTGGTCTTTGT
TTACTGTTTTACTAGATGCATGTGGAAGAGTCAGAAGAAATAGTTTTTGTTTGAAATGGTATACCAACGG
TTGGATATTATATTATCTGTGTGGACATCAGATGTTCTGGGTTACTGGCAGTGGACTTTGACAGATTTAT
CTATGATTCTTTCATTAGCAGTTTCTTCAGCTAATTTACTCTTACTATTTTTCAGTATACAAAGACACGT
ACAGCTAGGGTTGTGTAGAATCGTTTAAGATCTGTTATATGAGGCAAATTAGCTTATTCTAGCCGCCTGA
AATTTCTTGATTTTGCCAGTATCATAGAGAGTGTTGGAGAGGGTGTGACTGACGTAGCTCCGGGCGACCA
TGTCCTTCCTGTGTTCACTGGGGAGTGCAAGGAGTGCGCCCACTGCAAGTCGGCAGAGAGCAACATGTGT
GATTTGCTCAGGATCAACACTGACCGCGGTGTGATGATTGGCGATGGCAAGTCGCGGTTTTCAATCAATG
GGAAGCCTATCTACCACTTTGTTGGGACTTCCACCTTCAGCGAGTACACCGTCATGCATGTCGGTTGTGT
TGCAAAGATCAACCCTCAGGCTCCCCTTGATAAAGTTTGCGTCCTTAGCTGTGGTATTTCTACTGGTAAG
TTCAATTACTACATTTTGGTGTGGATGCTGGAGTACATTTATCTTGAGATGCTGAGTTACACAAATTCTT
TCTCTGTTTAGGTCTTGGTGCATCAATTAATGTTGCAAAACCTCCGAAGGGTTCGACAGTGGCTGTTTTC
GGTTTAGGAGCCGTTGGTCTTGCCGTAAGTGTTGAAACGATTTGCTTGTTCTATGACATTTCAATTGCAA
TGAGAATGTGTGTTGGGTTTGCATCTGATTACCCTGCGCATGGTTAAGGCTGCAGAAGGTGCAAGGATTG
CTGGAGCGTCAAGGATCATTGGTGTCGACCTGAACCCCAGCAGATTCGAAGAAGGTACAGTACACACACA
TGTATATATGTATGATGTATCCCTTCGATCGAAGGCATGCCTTGGTATAATCACTGAGTAGTCATTTTAT
TACTTTGTTTTGACAAGTCAGTAGTTCATCCATTTGTCCCATTTTTTCAGCTTGGAAGTTTGGTTGCACT
GGCACTTGGTCTAATAACTGAGTAGTCATTTTATTACGTTGTTTCGACAAGTCAGTAGCTCATCCATCTG
TCCCATTTTTTCAGCTAGGAAGTTTGGTTGCACTGGCCTTGGACTAATAACTGATTAGTCATTTTATTAC
ATTGTTTCGACAAGTCAGTAGCTCATCCATCTGTCCCATTTTTCAGCTAGGAAGTTCGGTTGCACTGAAT
TTGTGAACCCAAAAGACCACAACAAGCCGGTGCAGGAGGTCTGTTTCTTTACCCAAGGCAACAAAAGGTT
ATCACAGCTTATGCTGAACTTGGCCATAACATTCAATAATTCCTTTATGGTCTAGGTACTTGCTGAGATG
ACCAACGGAGGGGTCGACCGCAGCGTGGAATGCACTGGCAACATCAATGCTATGATCCAAGCTTTCGAAT
GTGTTCATGATGTAAGTATATGTATACACTCTCAGCTACTTTCATTCTCCAGGTTCCCTTCATCCAGACA
TGCATGTTCTAACCGCCGCCCTCGTGATCCAGGGCTGGGGTGTTGCCGTGCTGGTGGGTGTGCCGCATAA
GGACGCTGAGTTCAAGACCCACCCGATGAACTTCCTGAACGAAAGGACCCTGAAGGGGACCTTCTTTGGC
AACTATAAGCCACGCACTGATCTGCCAAATGTGGTGGAGCTGTACATGAAAAAGGTAAATTGCAAAGTGC
TGTTCCTTCAGTTTCCTTACCTGCCGAGCTTTTGCTGAAAAACTGTTAAGAATCGTTCCTGCAATTCTGC
ACAGGAGCTGGAGGTGGAGAAGTTCATCACGCACAGCGTCCCGTTCGCGGAGATCAACAAGGCGTTCAAC
CTGATGGCCAAGGGGGAGGGCATCCGCTGCATCATCCGCATGGAGAACTAGATTTCGCTGTCTAGTTTGT
GATCTGGCCTGGGCTTGGGGTTAATAAAGGAGGCAATGCTAGCCTGCCCTTTCGATGAGGAGGTACATAC
ACGCTGGCGATGGACCGCGCTTGTGTGTCGCGTTCAGTTTGGCTTTTGCCAAGCAGTAGGGTAGCTTCCC
GTGTCGGTAATTATATGGTATGAACCATCACCTTTTGGCGCAATACATGGTATGAACGTAAGATACAAAT
TCCAACTACCTCTAGCTCGCCGCTATCTGTATCAGTATGTATCTCTCTCGACGGATGACACAAGATCGAA
GAAGCAAATAACTAACTACACCTCGCTCCTATATCCGAAGTGAAACTAAAAGGAGAAGGAAAAGAAGGTA
ACAGAATAGGAACCGGTTTGATGAGAATCGGTTTGATGAGAATTGGAGAGGATTCATGAGAGAGAAAATC
CCTTTCCATTAAATTTTAAATAGCAAGTGAATTACTCTCATGATCTCCTCCAGTTTCCATTTCATCAAAA
CAAACCTTATTCATTTTCCCCTCTAATCTCTTAATTCTCTTGTCACCACCGGGAGCAAGGTGATTAAGGA
GACTAAAACCCTTCATCATTTAATGAATAGTAAGGGTTTTAGCCCTCTCAATTTCTCCAATACCTTGCTC
CCAAATAAATCCCTAAGAGCCGAGGAAGGGGATTAAAAAGGATAAAATCTTCTTTGTGTTCAATTTTGAA
TAGGACTCGCCGTATCGGTAAGGCTTCGCGGCGGGGCTCGCAGTCCGGACTGACGAGGGGGCTATGGAGA
TGGAGAATGACAAGGGGGCTGTTCTGGAAAGTTTCCTTTCCAAGAGTAAGGGTGGTTGGTTTCATACACT
AATTTTTAAGAACGTTTGGTTAAGAAACAGAGAAAAATAGAGTAACTCTATTCTTATTTTATTTTTTGAT
GTTTAGTTTTCAATAAAAAAGAGCACATTTGGAGTTTTCATATAAAAATTTATCATAAATAGTTAAAATG
CTCTCACTCCATAAAAACAATCGGATACTAGCGCTCTCCTTCCTATCCTACCCTCTATGCTCATATTGGC
TCTTCAACCGAAGAGAGAATGGAGGGGCTCCGTTCATTCACTCTTCAACCAAATAAAAAAGGAGCGACTA
TGTTCAGTTTGTCATACGCGGAATAGAACGGCTCTATCCTAAAAAACTAGAATAGAACCCCTCCATTTTA
GTTGACTCTCCAACCAAACGCATAGTCTCTCCATTCCATTCTATTTTAGTCTCTAAATTGACAAATACAT
AAACTAAATTGTATTTTAAGTTTTCGTATTTAATCAATCACTACAAACCAAACACTCCCTAATTTCGCAT
ATCAGCCCCAAATCAAGAGTGGTTGACCCATCGAGACGTTATCGCCGGATCAAAGGCATGCCCCGCTAAG
GCCTAGTTTGGATACTCTTGGATTGAAGTGGTTTGGAGGGATTAGAGGGTATTTAAATCCCCAATAGGTC
AAAAACTCTCACGATACATCTCAATCCACTCCATTCCCTCTTATTCCTAGAGTACCCAAACAAGCCTAAG
GCCTAGTTTGGATACTCTTGGATTGAAGTGGTTTGGAGGGATTAGAGGGTATTTAAATCCCCAATAGGTC
AAAAACTCTCACGATACATCTCAATCCACTCCATTCCCTCTTATTCCTAGAGTACCCAAACAAGCCTAAG
TGTCTAAACTAACGTGCCGTCGAC"""

# FILE UPLOAD FOR GOOGLE COLAB
print("\nüìÅ FILE UPLOAD OPTION FOR GOOGLE COLAB")
print("-" * 50)
print("1. Use default ADH1 sequence")
print("2. Upload your own sequence file (.txt or .fasta)")

choice = input("\nChoose option (1 or 2): ").strip()

if choice == "2":
    print("\nüì§ Please upload your sequence file:")
    print("   - Click the 'Choose Files' button below")
    print("   - Select your text or FASTA file")
    
    # Colab-specific file upload
    uploaded = files.upload()
    
    if uploaded:
        # Get the first uploaded file
        filename = list(uploaded.keys())[0]
        file_content = uploaded[filename].decode('utf-8')
        
        print(f"\n‚úÖ File '{filename}' loaded successfully!")
        print(f"   File size: {len(file_content)} characters")
        
        # Clean the uploaded sequence
        lines = file_content.split('\n')
        sequence_lines = []
        
        for line in lines:
            # Remove comment lines starting with #
            if line.strip().startswith('#'):
                continue
            # Remove FASTA headers starting with >
            if line.strip().startswith('>'):
                continue
            # Add sequence lines (strip whitespace and numbers)
            line_clean = ''.join([c for c in line.strip() if c.upper() in 'ATCGNRYSWKMBVDHU'])
            if line_clean:
                sequence_lines.append(line_clean.upper())
        
        adh1_sequence = ''.join(sequence_lines)
        print(f"   Cleaned sequence length: {len(adh1_sequence)} bp")
    else:
        print("‚ö†Ô∏è  No file uploaded. Using default sequence.")
        adh1_sequence = default_adh1_sequence
else:
    adh1_sequence = default_adh1_sequence
    print("\n‚úÖ Using default ADH1 sequence")

# Clean the sequence
adh1_clean = adh1_sequence.replace('\n', '').replace(' ', '').upper()
# Further clean to keep only DNA characters
adh1_clean = ''.join([c for c in adh1_clean if c in 'ATCGNRYSWKMBVDHU'])

print(f"\nüìä SEQUENCE STATISTICS")
print("-" * 40)
print(f"Total length: {len(adh1_clean):,} nucleotides")
gc_count = adh1_clean.count('G') + adh1_clean.count('C')
print(f"GC content: {gc_count/len(adh1_clean)*100:.1f}% ({gc_count:,} G/C bases)")
print(f"AT content: {(len(adh1_clean)-gc_count)/len(adh1_clean)*100:.1f}% ({len(adh1_clean)-gc_count:,} A/T bases)")
print(f"Database size: {len(adh1_clean):,} elements")

print("\n" + "="*60)
print("üîç SEARCHING FOR PCR PRIMERS")
print("="*60)

# Function to simulate quantum search
def quantum_search_simulation(target_sequence, database_sequence, primer_name):
    """Simulate quantum search for primer in sequence"""
    target = target_sequence.upper()
    database = database_sequence.upper()

    print(f"\nüéØ Searching for: {primer_name}")
    print(f"   Primer sequence: {target}")
    print(f"   Primer length: {len(target)} nucleotides")
    print(f"   Primer GC content: {((target.count('G') + target.count('C'))/len(target)*100):.1f}%")

    # MEASURE ACTUAL CLASSICAL SEARCH TIME
    start_time = time.perf_counter_ns()
    classical_position = database.find(target)
    end_time = time.perf_counter_ns()
    classical_time_ns = end_time - start_time
    
    classical_attempts = len(database) - len(target) + 1 if classical_position == -1 else classical_position + 1

    # Quantum search (theoretical)
    database_size = len(database) - len(target) + 1
    quantum_attempts = int(np.sqrt(database_size)) if database_size > 0 else 1
    
    # Estimate quantum time (with overhead)
    quantum_overhead_ns = 100000  # 100 Œºs overhead for quantum operations
    estimated_quantum_time_ns = quantum_overhead_ns + (quantum_attempts * 1000)  # 1 Œºs per quantum op

    # Check if found
    if classical_position != -1:
        print(f"   ‚úÖ FOUND at position: {classical_position + 1}")
        print(f"   ‚è±Ô∏è  Classical search time: {classical_time_ns/1000:.2f} Œºs")
        print(f"   üîç Classical comparisons: {classical_attempts:,}")
        print(f"   ‚öõÔ∏è  Quantum would need: ~{quantum_attempts:,} operations")
        print(f"   ‚è±Ô∏è  Estimated quantum time: {estimated_quantum_time_ns/1000:.2f} Œºs")
        
        if estimated_quantum_time_ns > 0:
            speedup = classical_time_ns / estimated_quantum_time_ns
            if speedup > 1:
                print(f"   üöÄ Quantum would be {speedup:.1f}x SLOWER (for this size)")
            else:
                print(f"   üöÄ Quantum would be {1/speedup:.1f}x FASTER")

        # Extract context
        start = max(0, classical_position - 20)
        end = min(len(database), classical_position + len(target) + 20)
        context = database[start:end]

        # Highlight primer in context
        if classical_position - start > 0:
            highlighted = context[:classical_position-start] + "[" + target + "]" + context[classical_position-start+len(target):]
        else:
            highlighted = "[" + target + "]" + context[len(target):]

        print(f"   üìç Context: ...{highlighted}...")
    else:
        print(f"   ‚ùå NOT FOUND in sequence")
        print(f"   ‚è±Ô∏è  Classical search time: {classical_time_ns/1000:.2f} Œºs")
        print(f"   üîç Classical comparisons: {classical_attempts:,}")
        print(f"   ‚öõÔ∏è  Quantum would need: ~{quantum_attempts:,} operations")

    return classical_position, classical_attempts, quantum_attempts, classical_time_ns, estimated_quantum_time_ns

# Search for all primers
results = {}
print("\n" + "="*60)
print("SEARCH RESULTS SUMMARY")
print("="*60)

for pair_name, primers in primer_pairs.items():
    print(f"\nüß¨ {pair_name}:")
    print("-" * 40)

    # Search forward primer
    fwd_pos, fwd_classical, fwd_quantum, fwd_time_ns, fwd_qtime_ns = quantum_search_simulation(
        primers["Fwd"], adh1_clean, f"Forward Primer ({len(primers['Fwd'])}nt)"
    )

    # Search reverse primer
    rev_pos, rev_classical, rev_quantum, rev_time_ns, rev_qtime_ns = quantum_search_simulation(
        primers["Rev"], adh1_clean, f"Reverse Primer ({len(primers['Rev'])}nt)"
    )

    # Store results
    results[pair_name] = {
        "Fwd": {
            "position": fwd_pos, 
            "classical": fwd_classical, 
            "quantum": fwd_quantum,
            "time_ns": fwd_time_ns,
            "qtime_ns": fwd_qtime_ns
        },
        "Rev": {
            "position": rev_pos, 
            "classical": rev_classical, 
            "quantum": rev_quantum,
            "time_ns": rev_time_ns,
            "qtime_ns": rev_qtime_ns
        },
        "Product_size": abs(fwd_pos - rev_pos) + len(primers["Fwd"]) if fwd_pos != -1 and rev_pos != -1 else None
    }

print("\n" + "="*60)
print("üìà PERFORMANCE ANALYSIS")
print("="*60)

# Performance comparison
for pair_name, result in results.items():
    print(f"\n{pair_name}:")
    if result["Fwd"]["position"] != -1 and result["Rev"]["position"] != -1:
        print(f"   ‚úÖ Both primers found!")
        print(f"   üìè Expected PCR product size: {result['Product_size']} bp")

        # Calculate totals
        total_classical = result["Fwd"]["classical"] + result["Rev"]["classical"]
        total_quantum = result["Fwd"]["quantum"] + result["Rev"]["quantum"]
        total_classical_time = (result["Fwd"]["time_ns"] + result["Rev"]["time_ns"]) / 1000  # Œºs
        total_quantum_time = (result["Fwd"]["qtime_ns"] + result["Rev"]["qtime_ns"]) / 1000  # Œºs

        print(f"   ‚è±Ô∏è  Total classical time: {total_classical_time:.2f} Œºs")
        print(f"   ‚è±Ô∏è  Total estimated quantum time: {total_quantum_time:.2f} Œºs")
        print(f"   üîç Total classical comparisons: {total_classical:,}")
        print(f"   ‚öõÔ∏è  Total quantum operations: ~{total_quantum:,}")
        
        if total_quantum_time > 0:
            speedup = total_classical_time / total_quantum_time
            if speedup > 1:
                print(f"   ‚ö†Ô∏è  Quantum would be {speedup:.1f}x SLOWER (for this sequence size)")
            else:
                print(f"   üöÄ Quantum would be {1/speedup:.1f}x FASTER")
    else:
        print(f"   ‚ö†Ô∏è  One or both primers not found")

print("\n" + "="*60)
print("üî¨ SEQUENCE ANALYSIS")
print("="*60)

# Special finding for Pair 1 Forward primer
pair1_fwd_sequence = primer_pairs["Pair 1"]["Fwd"]
pair1_fwd_position = results["Pair 1"]["Fwd"]["position"]

if pair1_fwd_position != -1:
    print(f"\nüéØ INTERESTING FINDING: Pair 1 Forward Primer")
    print(f"   Primer: {pair1_fwd_sequence}")
    print(f"   Found at position: {pair1_fwd_position + 1}")

    # Extract more context
    context_start = max(0, pair1_fwd_position - 50)
    context_end = min(len(adh1_clean), pair1_fwd_position + len(pair1_fwd_sequence) + 50)
    
    context_before = adh1_clean[context_start:pair1_fwd_position]
    primer_in_context = adh1_clean[pair1_fwd_position:pair1_fwd_position + len(pair1_fwd_sequence)]
    context_after = adh1_clean[pair1_fwd_position + len(pair1_fwd_sequence):context_end]

    print(f"\n   üìç Extended context (100bp window):")
    print(f"   ...{context_before}[{primer_in_context}]{context_after}...")

print("\n" + "="*60)
print("üìä VISUALIZATION")
print("="*60)

# Create visualization
fig, axes = plt.subplots(2, 2, figsize=(14, 10))

# Plot 1: Search times
ax1 = axes[0, 0]
classical_times = []
quantum_times = []
primer_names = []

for pair_name, result in results.items():
    for primer_type in ["Fwd", "Rev"]:
        if result[primer_type]["position"] != -1:
            primer_names.append(f"{pair_name} {primer_type}")
            classical_times.append(result[primer_type]["time_ns"] / 1000)  # Œºs
            quantum_times.append(result[primer_type]["qtime_ns"] / 1000)  # Œºs

x = np.arange(len(primer_names))
width = 0.35

ax1.bar(x - width/2, classical_times, width, label='Classical (actual)', color='blue', alpha=0.7)
ax1.bar(x + width/2, quantum_times, width, label='Quantum (estimated)', color='red', alpha=0.7)
ax1.set_xlabel('Primer')
ax1.set_ylabel('Time (Œºs)')
ax1.set_title('Search Time Comparison')
ax1.set_xticks(x)
ax1.set_xticklabels(primer_names, rotation=45, ha='right')
ax1.legend()
ax1.grid(True, alpha=0.3)

# Plot 2: GC content comparison
ax2 = axes[0, 1]
sequence_gc = gc_count/len(adh1_clean)*100
primer_gc_values = []
primer_labels = []

for pair_name, primers in primer_pairs.items():
    for primer_type, seq in primers.items():
        primer_gc = (seq.count('G') + seq.count('C'))/len(seq)*100
        primer_gc_values.append(primer_gc)
        primer_labels.append(f"{pair_name}\n{primer_type}")

ax2.axhline(y=sequence_gc, color='green', linestyle='--', label=f'Sequence GC ({sequence_gc:.1f}%)')
ax2.bar(range(len(primer_gc_values)), primer_gc_values, color='orange', alpha=0.7)
ax2.set_xlabel('Primer')
ax2.set_ylabel('GC Content (%)')
ax2.set_title('GC Content Comparison')
ax2.set_xticks(range(len(primer_gc_values)))
ax2.set_xticklabels(primer_labels)
ax2.legend()
ax2.grid(True, alpha=0.3)

# Plot 3: Speedup vs sequence size
ax3 = axes[1, 0]
sequence_sizes = np.logspace(3, 9, 50)  # 1k to 1G bp
classical_estimates = sequence_sizes * 0.001  # 1 ns per comparison
quantum_estimates = 100 + np.sqrt(sequence_sizes) * 1  # 100 Œºs overhead + 1 Œºs per ‚àön op

ax3.plot(sequence_sizes, classical_estimates, 'b-', label='Classical O(n)', linewidth=2)
ax3.plot(sequence_sizes, quantum_estimates, 'r-', label='Quantum O(‚àön)', linewidth=2)
ax3.axvline(x=len(adh1_clean), color='green', linestyle='--', 
            label=f'Current sequence\n({len(adh1_clean):,} bp)')
ax3.set_xscale('log')
ax3.set_yscale('log')
ax3.set_xlabel('Sequence Size (bp)')
ax3.set_ylabel('Estimated Time (Œºs)')
ax3.set_title('Theoretical Scaling')
ax3.legend()
ax3.grid(True, alpha=0.3)

# Plot 4: Product size if found
ax4 = axes[1, 1]
product_sizes = []
pair_labels = []

for pair_name, result in results.items():
    if result["Product_size"]:
        product_sizes.append(result["Product_size"])
        pair_labels.append(pair_name)

if product_sizes:
    colors = ['gold', 'lightcoral', 'lightblue', 'lightgreen']
    ax4.pie(product_sizes, labels=pair_labels, autopct='%1.1f%%', colors=colors[:len(product_sizes)])
    ax4.set_title('PCR Product Size Distribution')
else:
    ax4.text(0.5, 0.5, 'No valid primer pairs found\nfor PCR product calculation', 
             ha='center', va='center', fontsize=12)
    ax4.set_title('PCR Product Analysis')

plt.tight_layout()
plt.show()

print("\n" + "="*60)
print("üí° KEY INSIGHTS")
print("="*60)

print("""
1. **Classical vs Quantum Reality:**
   ‚Ä¢ Your ACTUAL search uses Python's str.find() (classical Boyer-Moore)
   ‚Ä¢ The "quantum" calculations are THEORETICAL estimates
   ‚Ä¢ For small sequences (< 1M bp), classical is FASTER than quantum

2. **Performance Summary:**
   ‚Ä¢ Classical search: O(n) time, optimized C implementation
   ‚Ä¢ Quantum search: O(‚àön) time, but with large constant overhead
   ‚Ä¢ Crossover point: Quantum becomes faster at ~10M-100M elements

3. **Your Results Are:**
   ‚Ä¢ Classical times: ACTUAL measurements (Œºs)
   ‚Ä¢ Quantum times: THEORETICAL estimates with overhead
   ‚Ä¢ Speedup claims: Based on asymptotic analysis, not actual quantum computation

4. **Recommendations:**
   ‚Ä¢ For gene-scale searches (< 100k bp): Classical is optimal
   ‚Ä¢ For genome-scale searches (> 10M bp): Consider specialized tools (BLAST, BWA)
   ‚Ä¢ Quantum advantage: Theoretical for now, practical in future with better hardware
""")

print("\n" + "="*60)
print("‚úÖ SEARCH COMPLETE")
print("="*60)

# Summary statistics
total_classical_time = sum(r["Fwd"]["time_ns"] + r["Rev"]["time_ns"] for r in results.values()) / 1000
total_quantum_time = sum(r["Fwd"]["qtime_ns"] + r["Rev"]["qtime_ns"] for r in results.values()) / 1000

print(f"Database scanned: {len(adh1_clean):,} nucleotides")
print(f"Primer pairs searched: {len(primer_pairs)}")
print(f"Total classical search time: {total_classical_time:.2f} Œºs")
print(f"Total estimated quantum time: {total_quantum_time:.2f} Œºs")

if total_quantum_time > 0:
    speedup_ratio = total_classical_time / total_quantum_time
    if speedup_ratio > 1:
        print(f"Conclusion: Classical is {speedup_ratio:.1f}x FASTER than quantum for this search")
    else:
        print(f"Conclusion: Quantum would be {1/speedup_ratio:.1f}x FASTER than classical")

print("\n" + "="*60)
print("üéâ ANALYSIS COMPLETE - READY FOR PCR DESIGN!")
print("="*60)

# Optional: Save results
print("\nüíæ Would you like to save the results?")
save_choice = input("Enter 'y' to save results to file, or any other key to skip: ").strip().lower()

if save_choice == 'y':
    filename = "primer_search_results.txt"
    with open(filename, 'w') as f:
        f.write("PCR PRIMER SEARCH RESULTS\n")
        f.write("="*50 + "\n\n")
        f.write(f"Sequence: {len(adh1_clean)} bp\n")
        f.write(f"GC content: {gc_count/len(adh1_clean)*100:.1f}%\n\n")
        
        f.write("PRIMER PAIRS:\n")
        for pair_name, primers in primer_pairs.items():
            f.write(f"\n{pair_name}:\n")
            f.write(f"  Forward: {primers['Fwd']}\n")
            f.write(f"  Reverse: {primers['Rev']}\n")
            
            if pair_name in results:
                r = results[pair_name]
                fwd_pos = r["Fwd"]["position"]
                rev_pos = r["Rev"]["position"]
                
                f.write(f"  Forward position: {fwd_pos + 1 if fwd_pos != -1 else 'Not found'}\n")
                f.write(f"  Reverse position: {rev_pos + 1 if rev_pos != -1 else 'Not found'}\n")
                
                if r["Product_size"]:
                    f.write(f"  Expected PCR product: {r['Product_size']} bp\n")
        
        f.write(f"\nPERFORMANCE:\n")
        f.write(f"  Total classical time: {total_classical_time:.2f} Œºs\n")
        f.write(f"  Total estimated quantum time: {total_quantum_time:.2f} Œºs\n")
    
    print(f"‚úÖ Results saved to '{filename}'")
    print("   You can download it from the Colab file browser on the left.")

print("\n‚ú® Ready for your next analysis!")
