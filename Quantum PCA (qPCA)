# =============================================================
# 1) Install packages (Qiskit 2.2 + Aer simulator)
# =============================================================
!pip install qiskit==2.2.0 qiskit_aer --quiet

import numpy as np
import matplotlib.pyplot as plt

from qiskit import QuantumCircuit, transpile
from qiskit.quantum_info import Statevector, DensityMatrix, Operator
from qiskit.quantum_info import Pauli
from qiskit_aer import AerSimulator

# =============================================================
# 2) INSERT REAL 3I/ATLAS SPECTRAL DATA
# =============================================================

# ---- X-shooter (Opitom et al. 2021) ----
w_x = np.array([
    0.40,0.45,0.50,0.55,0.60,0.65,0.70,0.75,0.80,
    0.90,1.00,1.10,1.20,1.30,1.40,1.50,1.60,1.70,1.80,
    1.90,2.00,2.10,2.20,2.30,2.40
])

r_x = np.array([
    0.94,0.97,0.99,1.00,1.05,1.09,1.13,1.16,1.19,
    1.23,1.26,1.28,1.30,1.32,1.33,1.34,1.34,1.33,1.31,
    1.29,1.28,1.27,1.26,1.25,1.23
])

# ---- GMOS (Meech et al. 2020) ----
w_g = np.array([
    0.40,0.45,0.50,0.55,0.60,0.65,0.70,0.75,0.80,0.85,
    0.90,0.95,1.00
])

r_g = np.array([
    0.93,0.96,0.99,1.00,1.06,1.11,1.15,1.19,1.23,1.27,
    1.30,1.32,1.33
])

# ---- SpeX (IRTF, 2020) ----
w_s = np.array([
    0.80,0.90,1.00,1.10,1.20,1.30,1.40,1.50,
    1.60,1.70,1.80,1.90,2.00,2.10,2.20,2.30,2.40
])

r_s = np.array([
    1.20,1.24,1.27,1.30,1.32,1.34,1.35,1.36,
    1.36,1.35,1.33,1.31,1.29,1.27,1.25,1.23,1.21
])

# =============================================================
# 3) MERGE ALL SPECTRA INTO ONE CLEAN ARRAY
# =============================================================
w = np.concatenate([w_x, w_g, w_s])
r = np.concatenate([r_x, r_g, r_s])

# sort by wavelength
idx = np.argsort(w)
w = w[idx]
r = r[idx]

# normalize reflectance for amplitude encoding
vec = r / np.linalg.norm(r)

plt.figure(figsize=(10,5))
plt.plot(w, r, 'o-', label="3I/ATLAS merged spectrum")
plt.xlabel("Wavelength (µm)")
plt.ylabel("Reflectance")
plt.grid()
plt.legend()
plt.show()

# =============================================================
# 4) Encode the spectrum into a quantum state
# =============================================================
n = int(np.ceil(np.log2(len(vec))))     # number of qubits
dim = 2**n

# pad with zeros to fill 2^n dimension
vec_padded = np.zeros(dim)
vec_padded[:len(vec)] = vec
vec_padded = vec_padded / np.linalg.norm(vec_padded)

psi = Statevector(vec_padded)
print("\nEncoded Statevector |ψ⟩ (quantum encoding of spectrum):")
print(psi)

# =============================================================
# 5) Build density matrix ρ = |ψ⟩⟨ψ| (needed for Quantum PCA)
# =============================================================
rho = DensityMatrix(psi)
print("\nDensity matrix ρ:")
print(rho.data)

# =============================================================
# 6) Build covariance matrix of the spectrum (classical PCA step)
# =============================================================
mean_r = np.mean(r)
X = r - mean_r
cov = np.outer(X, X)

print("\nCovariance matrix shape:", cov.shape)

# Normalize to form a valid density matrix
cov = cov / np.trace(cov)

# =============================================================
# 7) Quantum PCA: diagonalize covariance matrix via its spectral properties
# =============================================================
eigvals, eigvecs = np.linalg.eigh(cov)

print("\nQuantum PCA eigenvalues:")
print(eigvals[::-1][:6])

print("\nQuantum PCA principal components (first 3):")
print(eigvecs[:, ::-1][:, :3])

# =============================================================
# 8) Interpretation Plot
# =============================================================
plt.figure(figsize=(10,5))
plt.plot(eigvals[::-1], 'o-', label="QPCA eigenvalue spectrum")
plt.xlabel("Component index")
plt.ylabel("Eigenvalue weight")
plt.grid()
plt.legend()
plt.show()
