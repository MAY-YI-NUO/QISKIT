# Tutorial
# Instalare pachete necesare pentru Google Colab
!pip install qiskit qiskit-aer pylatexenc

%matplotlib inline
import numpy as np
from qiskit import QuantumCircuit
from qiskit_aer import AerSimulator
from qiskit.visualization import plot_histogram, plot_bloch_multivector
from IPython.display import display

print("=== CALCUL CUANTIC - NOȚIUNI DE BAZĂ ===")
print("Acest cod demonstrează concepte de bază ale calculului cuantic\n")

# ============================================
# 1. CREAREA UNUI QUBIT ÎN SUPERPOZIȚIE
# ============================================
print("1. CREAREA SUPERPOZIȚIEI CU PORTA HADAMARD")

# Circuit cu un singur qubit
qc_single = QuantumCircuit(1, 1)  # 1 qubit, 1 bit clasic

# Aplică poarta Hadamard pentru a crea superpoziție
qc_single.h(0)

# Măsoară qubitul
qc_single.measure(0, 0)

print("\nCircuitul pentru superpoziție:")
print(qc_single.draw())

# Rulează simularea
simulator = AerSimulator()
result = simulator.run(qc_single, shots=1000).result()
counts = result.get_counts()

print(f"\nRezultate pentru 1000 execuții:")
print(f"|0⟩: {counts.get('0', 0)} măsurători (~50% așteptat)")
print(f"|1⟩: {counts.get('1', 0)} măsurători (~50% așteptat)")

# ============================================
# 2. ENTANGLEMENT (ÎMPLECȚIRE CUANTICĂ)
# ============================================
print("\n\n2. CREAREA ENTANGLEMENT-ULUI (STARE BELL)")

# Circuit pentru stare Bell (maximal entangled)
qc_bell = QuantumCircuit(2, 2)  # 2 qubiți, 2 biți clasici

# Aplică Hadamard pe primul qubit
qc_bell.h(0)

# Aplică CNOT pentru a crea entanglement
qc_bell.cx(0, 1)  # Qubit 0 este control, Qubit 1 este țintă

# Măsoară ambii qubiți
qc_bell.measure([0, 1], [0, 1])

print("\nCircuitul pentru stare Bell:")
print(qc_bell.draw())

# Rulează simularea
result_bell = simulator.run(qc_bell, shots=1000).result()
counts_bell = result_bell.get_counts()

print(f"\nRezultatele stării Bell:")
print("Într-o stare Bell perfectă, obținem doar |00⟩ și |11⟩")
for state in ['00', '01', '10', '11']:
    count = counts_bell.get(state, 0)
    print(f"|{state}⟩: {count} măsurători")

# ============================================
# 3. PORȚI CUANTICE DE BAZĂ
# ============================================
print("\n\n3. DEMONSTRAREA PORȚILOR CUANTICE DE BAZĂ")

# Testează diferite porți cuantice
test_gates = QuantumCircuit(3, 3)

# Poarta X (NOT cuantic) pe qubit 0
test_gates.x(0)

# Poarta Y pe qubit 1
test_gates.y(1)

# Poarta Z pe qubit 2
test_gates.z(2)

# Măsoară toți qubiții
test_gates.measure([0, 1, 2], [0, 1, 2])

print("\nCircuit cu diferite porți cuantice:")
print(test_gates.draw())

# ============================================
# 4. ALGORITM CUANTIC SIMPLU: DEUTSCH-JOZSA
# ============================================
print("\n\n4. ALGORITMUL DEUTSCH-JOZSA (SIMPLIFICAT)")

def deutsch_jozsa_constant():
    """Implementare simplificată a algoritmului Deutsch-Jozsa pentru funcție constantă"""
    qc = QuantumCircuit(2, 1)

    # Inițializează qubiții
    qc.x(1)  # Aplică X pe al doilea qubit
    qc.h(0)  # Hadamard pe primul qubit
    qc.h(1)  # Hadamard pe al doilea qubit

    # Oracle pentru funcție constantă f(x) = 0
    # Nu facem nimic - funcția constantă

    qc.h(0)  # Hadamard din nou

    # Măsoară primul qubit
    qc.measure(0, 0)

    return qc

def deutsch_jozsa_balanced():
    """Implementare simplificată a algoritmului Deutsch-Jozsa pentru funcție balansată"""
    qc = QuantumCircuit(2, 1)

    # Inițializează qubiții
    qc.x(1)  # Aplică X pe al doilea qubit
    qc.h(0)  # Hadamard pe primul qubit
    qc.h(1)  # Hadamard pe al doilea qubit

    # Oracle pentru funcție balansată f(x) = x (CNOT)
    qc.cx(0, 1)

    qc.h(0)  # Hadamard din nou

    # Măsoară primul qubit
    qc.measure(0, 0)

    return qc

print("\nTestăm algoritmul Deutsch-Jozsa:")

# Test pentru funcție constantă
qc_constant = deutsch_jozsa_constant()
result_constant = simulator.run(qc_constant, shots=100).result()
constant_counts = result_constant.get_counts()

# Test pentru funcție balansată
qc_balanced = deutsch_jozsa_balanced()
result_balanced = simulator.run(qc_balanced, shots=100).result()
balanced_counts = result_balanced.get_counts()

print(f"\nFuncție constantă - rezultate: {constant_counts}")
print(f"Funcție balansată - rezultate: {balanced_counts}")

print("\nInterpretare:")
print("- Dacă măsurăm întotdeauna |0⟩: funcție constantă")
print("- Dacă măsurăm întotdeauna |1⟩: funcție balansată")

# ============================================
# 5. VIZUALIZARE REZULTATE
# ============================================
print("\n\n5. VIZUALIZARE GRAFICĂ A REZULTATELOR")

# Histogramă pentru stare Bell
print("\nHistograma stării Bell:")
plot_histogram(counts_bell)

# Comparație algoritm Deutsch-Jozsa
from qiskit.visualization import plot_histogram
import matplotlib.pyplot as plt

fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(12, 4))

# Histogramă pentru funcție constantă
plot_histogram(constant_counts, ax=ax1)
ax1.set_title('Funcție Constantă (f(x) = 0)')

# Histogramă pentru funcție balansată
plot_histogram(balanced_counts, ax=ax2)
ax2.set_title('Funcție Balansată (f(x) = x)')

plt.suptitle('Algoritmul Deutsch-Jozsa', fontsize=14)
plt.tight_layout()
plt.show()

# ============================================
# 6. CONCLUZII
# ============================================
print("\n" + "="*50)
print("CONCLUZII ȘI CONCEPTE CHEIE")
print("="*50)

concepte = {
    "Superpoziție": "Un qubit poate fi în stări |0⟩ și |1⟩ simultan",
    "Entanglement": "Qubiții pot fi corelați perfect, indiferent de distanță",
    "Măsurare": "Colapsează starea cuantică într-o stare clasică",
    "Calcul Cuantic": "Poate rezolva anumite probleme exponențial mai rapid"
}

for concept, descriere in concepte.items():
    print(f"• {concept}: {descriere}")

print("\n" + "="*50)
print("Acest cod demonstrează noțiunile de bază ale calculului cuantic.")
print("Rulează perfect în Google Colab cu Qiskit 2.2.3!")
print("="*50)
